import React, {useState} from "react";

//1. Есть объект state в компоненте, описывающий состояния компонента,  и если он меняется, то реакт перерисовывает непосредственно ту область где этот state выводится 
// 2. В классовых компонентах следующая последовательность выполнения действий: создается this.setState({a: 1}), затем запускается зарисовка -> this.render()
// 3. При переходе к функциональным компонентам(более легковестные, т.к. не нужно наследоваться от определенного класса) данный подход стал невозможен.
// 4. Для обеспечения того же функционала, что и в классовых компонентах, в реакте были созданы изолированные функции, которые повторяли механизмы работы сущностей классовых компонентов
// 5. Код становится более гибким и более масштабируемым
// 6. Кортеж - массив с заранее определенными элементами

// 11. Мы хотим получить начальное значение в state путем вычисления его в сторонней функции
// Вычисления как правило нагружают работу приложения
// Получаем проблему, что каждый раз, когда мы производим какие-либо действия в приложении данное значение каждый раз пересчитывается, тем самым нагружая работоспособность приложения
// Для оптимизации необходимо передавать данное вычисление через callback
// Таким образом значение будет вычислено однажды и в последствии вычисляться не будет
function computeInitialCount() {
    // console.log('Some calculation...')
    return Math.trunc(Math.random() * 20)
}


function UseStateComponent() {
    //7. Хорошая практика определять state в самом верху компонента(работать со state начинает при старте)
    //8. Мы не можем в условиях создавать state
    //9. Функцию useState мы можем вызывать сколько угодно раз
    // const [counter, setCounter] = useState(0)
    const [counter, setCounter] = useState(() => computeInitialCount())

    //10. Работа хука асинхронно
    // Если в функции increase вызвать два раза подряд функцию setCounter,
    // то второй раз она не отработает
    /*function increase() {
        setCounter(counter + 1)
        setCounter(counter + 1)
    } */
    // Все это происходит из-за того, что после вызова setCounter вызывается функция рендеринга для того чтобы визуально отобразить изменение компонента
    // Когда мы параллельно вызываем setCounter сам counter остается тем же
    // решение данной проблемы состоит в следующем:
    // setCounter может по другому принимать входные значения
    // к примеру, принимает callback функцию, которая, в свою очередь принимает предыдущее состояние, дальше из callback нам необходимо вернуть какое-то измененное значение и затем поместить в state
    // Теперь при каждом вызове setCounter мы обращаемся к предыдущему состоянию

    // 12. Работа state с объектами
    // Как в классовых компонентах работать с таким state нельзя, при изменении одного из полей объект полностью перезапишется, останется лишь то поле которое мы изменили
    // Для сохранения исходной структуры объекта необходимо применять спред объекта предыдущего состояния в handler-е 
    // А вообще это редко где можно встретить, обычно для каждого поля создают свой state
    const [state, setState] = useState({
        title: 'Счетчик',
        date: Date.now()
    })

    function increase() {
        setCounter(prevCounter => {
            return prevCounter + 1
        })
        // setCounter(prev => prev + 1)
    } 

    function decrease() {
        setCounter(counter - 1)
    } 

    // 12.
    function updateTitle() {
        setState(prev => {
            return {
                ...prev,
                title: 'Новое название'
            }
        })
    }

    return (
        <div style={{width: '400px', margin: '100px auto 0'}}>
            <h1>Счетчик: {counter}</h1>
            <button className="btn btn-success" onClick={increase}>Добавить</button>
            <button className="btn btn-danger" onClick={decrease}>Убрать</button>
            <button className="btn btn-primary" onClick={updateTitle}>Изменить название</button>
            <pre>{JSON.stringify(state, null, 2)}</pre>
        </div>
    )
}

export default UseStateComponent